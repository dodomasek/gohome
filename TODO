DEMOS:
1. Be able to log all raw events in memory, keep last X events
2. Save events to a file
3. Load saved events from file, log file
4. Show all logs as a friendly string



Object Model
System
Device
Button
Scene
Zone
Action
Command
ButtonTrigger
CookBook
Connection
Event
EventBroker
Ingredient
Recipe
RecipeManager
Trigger



Logger
- Listens for events, log to console, log to file
- Reads from file on startup










Logging
 - when a scene was set
 - when user pushed a button on a device
 - when an action was triggered
 - connections, rethink ...

Larger Goals
 - user management
X - recipes page
 - status page
 - event page, see all the events that have happened in the system
   - require watching tcp connection ...., reading and converting actions
   - pretty print commands
 - connect with other devices e.g. thermostat, shades, lights, activity sensors
 - Have a floorplan view of your house, can click to control lights, get current light levels
 - Energy usage


Stream events
 - channel where you can listen to events
 - events contain object that correspond to actual actions e.g. set scene action
 - can save these actions then replay them at a later time


Smart Bridge Pro
 - limited telnet support
 - trap http traffic on the network, see what messages are being sent to the device for:
   - creating a scene


Scenarios
- Turn on outside light when it starts to get dark
- Turn off outside light after 11pm
- Choose a particular scene
- Set individual lights
- Vacation mode, replays the last week of interactions (specified date range)
- Have a page showing all of the logs for the system
- Be alerted when something changes in your house when you are not there


Open questions
 - how to know what a scene means?
 - how to know when a scene is active?


//TODO: Only enabled at certain times of the day ?
//e.g. after 11am, before 5am, single press should go to preset level - recipes active ?
// - maybe at recipe level there is the option to say when this recipe should be active


Realtime - still no realtime feedback on the state of the system
 - Get the level of every zone in the system
 - What are the active scenes
 - Could make your own scenes

Device - you can give the format string for press button, release button etc applied to all its buttons
Templates that you load in have all this formatting strings that users can use ...
Import and uses the templates to know how to finalize information
Button
 ID
 Name
 Description
 PressCommand
 ReleaseCommand

CompositeCommand
 - collection of one or more commands

Setup page ... -> after import shows the current state of the system which you can then modify

Connections
 - pool
 - handle disconnect/reconnect
 - open a connection ...

Getting to v1.0
 - Expose buttons as own objects : X
 - Import integration reports (give name, can use on startup based on name)
 - Read in own json format on load
 - Edit gohome integration format (webpage or just manual?)
 - Logging of everything in the system -> to file
 - Recipes
 - Solid connection handling
 - Users? Multiple user scenario
 - Visual control + monitor software
 - Ability to monitor the state of the system, not just changes but current state too
   - how to distinguish between that fetch and control since they all look the same?
 - Status page, shows the log output in the system

Importing
 - Choose integration report device
 - e.g. SBP
 - Has an import templates
 - Each device has connectionInfo section that can be filled out
 - Template for SBP
   - Bool, buttons are scenes, that is on a device
   - Button Press Command (format strings, with placeholders to known constants)
   - Button Release Command (format strings)
   - Set Scene Command (format strings)
   - Set Zone Intensity command
 - Each device needs master device, this is who we communicate to to send commands
 - input for ID
 - Name of system, this is what will be saved
 - Bool - if this system should be used at startup

Exporting
 - Option to export system to a file
 - Need to save references to objects, not actual objects e.g. button device should be an id, not reference so we get same object
 - Need to be able to save to a known name, so can save multiple systems
 - Version number
 - Date Last Modified
 - Date Created


System
 - Devices Collection
 - Scenes Collection
 - Zones Collection
 - Buttons Collection
 - Recipes Collection

type CollectionUtil interface {
     ItemWithID(collection, id)
     ForEach(collection, id, func(item interface{}))
     Len(collection)
}

package collections
- Collection
- SystemCollections
  Device -> Collection
  Scenes
  Zones
  Buttons
  Recipes


OM Validation

jsx
//mixin
fieldChanged: function(evt) {
    var st = evt.target['data-state']
    var val = evt.target.value
    this.state.name = val
}

errInfo: function(errors, inputid, msg) {
    // returns help block if there is an error
}
<input data-state="zone.name" value={this.state.zone.name} onChange={this.fieldChanged} id={} />

//Validation error response

{
    errors: {
       "field1": {
           "message": "is a required field"
       },
       "field2": {
           "message": "foo device cannot control a flux wifi zone"
       }
   }
}




package gohome

/*
import (
	"bufio"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/markdaws/gohome/cmd"
	"github.com/markdaws/gohome/comm"
	"github.com/markdaws/gohome/event"
	"github.com/markdaws/gohome/log"
)

//TODO: make lutron package
type Lbdgpro2whDevice struct {
	device
	pool comm.ConnectionPool
}

func (d *Lbdgpro2whDevice) ModelNumber() string {
	return "L-BDGPRO2-WH"
}

func (d *Lbdgpro2whDevice) StartProducingEvents() (<-chan event.Event, <-chan bool) {
	d.evpDone = make(chan bool)
	d.evpFire = make(chan event.Event)

	if d.Stream() {
		go d.startStreaming()
	}
	return d.evpFire, d.evpDone
}

func (d *Lbdgpro2whDevice) Authenticate(c comm.Connection) error {
	r := bufio.NewReader(c)
	_, err := r.ReadString(':')
	if err != nil {
		return fmt.Errorf("authenticate login failed: %s", err)
	}

	_, err = c.Write([]byte(d.auth.Login + "\r\n"))
	if err != nil {
		return fmt.Errorf("authenticate write login failed: %s", err)
	}

	_, err = r.ReadString(':')
	if err != nil {
		return fmt.Errorf("authenticate password failed: %s", err)
	}

	_, err = c.Write([]byte(d.auth.Password + "\r\n"))
	if err != nil {
		return fmt.Errorf("authenticate password failed: %s", err)
	}
	return nil
}

func (d *Lbdgpro2whDevice) Connect() (comm.Connection, error) {
	c := d.pool.Get()
	if c == nil {
		return nil, fmt.Errorf("%s - connect failed, no connection available", d)
	}
	return c, nil
}

func (d *Lbdgpro2whDevice) ReleaseConnection(c comm.Connection) {
	d.pool.Release(c)
}

func (d *Lbdgpro2whDevice) startStreaming() {
	//TODO: Stop?
	for {
		err := d.stream()
		if err != nil {
			log.E("%s streaming failed: %s", d, err)
		}
		time.Sleep(10 * time.Second)
	}
}

func (d *Lbdgpro2whDevice) stream() error {
	log.V("%s attemping to stream events", d)
	conn, err := d.Connect()
	if err != nil {
		return fmt.Errorf("%s unable to connect to stream events: %s", d, err)
	}

	defer func() {
		d.ReleaseConnection(conn)
	}()

	log.V("%s streaming events", d)
	scanner := bufio.NewScanner(conn)
	split := func(data []byte, atEOF bool) (advance int, token []byte, err error) {

		//Match first instance of ~OUTPUT|~DEVICE.*\r\n
		str := string(data[0:])
		indices := regexp.MustCompile("[~|#][OUTPUT|DEVICE].+\r\n").FindStringIndex(str)

		//TODO: Don't let input grow forever - remove beginning chars after reaching max length

		if indices != nil {
			token = []byte(string([]rune(str)[indices[0]:indices[1]]))
			advance = indices[1]
			err = nil
		} else {
			advance = 0
			token = nil
			err = nil
		}
		return
	}

	scanner.Split(split)
	for scanner.Scan() {
		if d.evpFire != nil {
			orig := scanner.Text()
			if cmd := d.parseCommandString(orig); cmd != nil {
				d.evpFire <- event.New(d.ID(), cmd, orig)
			}
		}
	}

	log.V("%s stopped streaming events", d)
	if err := scanner.Err(); err != nil {
		return fmt.Errorf("%s error streaming events, streaming stopped: %s", d, err)
	}
	return nil

	//TODO: When?
	//if d.evpDone != nil {
	//close(d.evpDone)
	//}
}

func (d *Lbdgpro2whDevice) parseCommandString(cmd string) cmd.Command {
	switch {
	case strings.HasPrefix(cmd, "~OUTPUT"),
		strings.HasPrefix(cmd, "#OUTPUT"):
		return d.parseZoneCommand(cmd)

	case strings.HasPrefix(cmd, "~DEVICE"),
		strings.HasPrefix(cmd, "#DEVICE"):
		return d.parseDeviceCommand(cmd)
	default:
		// Ignore commands we don't care about
		return nil
	}
}

func (d *Lbdgpro2whDevice) parseDeviceCommand(command string) cmd.Command {
	matches := regexp.MustCompile("[~|#]DEVICE,([^,]+),([^,]+),(.+)\r\n").FindStringSubmatch(command)
	if matches == nil || len(matches) != 4 {
		return nil
	}

	deviceID := matches[1]
	componentID := matches[2]
	cmdID := matches[3]
	sourceDevice := d.Devices()[deviceID]
	if sourceDevice == nil {
		return nil
	}

	var finalCmd cmd.Command
	switch cmdID {
	case "3":
		if btn := sourceDevice.Buttons()[componentID]; btn != nil {
			finalCmd = &cmd.ButtonPress{
				ButtonAddress: btn.Address,
				ButtonID:      btn.ID,
				DeviceName:    d.Name(),
				DeviceAddress: d.Address(),
				DeviceID:      d.ID(),
			}
		}
	case "4":
		if btn := sourceDevice.Buttons()[componentID]; btn != nil {
			finalCmd = &cmd.ButtonRelease{
				ButtonAddress: btn.Address,
				ButtonID:      btn.ID,
				DeviceName:    d.Name(),
				DeviceAddress: d.Address(),
				DeviceID:      d.ID(),
			}
		}
	default:
		return nil
	}

	return finalCmd
}

func (d *Lbdgpro2whDevice) parseZoneCommand(command string) cmd.Command {
	matches := regexp.MustCompile("[~|?]OUTPUT,([^,]+),([^,]+),(.+)\r\n").FindStringSubmatch(command)
	if matches == nil || len(matches) != 4 {
		return nil
	}

	zoneID := matches[1]
	cmdID := matches[2]
	level, err := strconv.ParseFloat(matches[3], 64)
	if err != nil {
		return nil
	}

	z := d.Zones()[zoneID]
	if z == nil {
		return nil
	}

	var finalCmd cmd.Command
	switch cmdID {
	case "1":
		finalCmd = &cmd.ZoneSetLevel{
			ZoneAddress: z.Address,
			ZoneID:      z.ID,
			ZoneName:    z.Name,
			Level:       cmd.Level{Value: float32(level)},
		}
	default:
		return nil
	}

	return finalCmd
}
*/
